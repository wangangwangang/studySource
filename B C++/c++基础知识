~什么是STL？
	
	
~new/delete的使用：
	1）语法：new  数据类型
	2）用途一：int* p=new int;        delete p;        
	   用途二：int* p=new int[10]     delete p[];
	   
	3）注意：
		（1）new不同于malloc(),不是函数
		（2）int* p=new int(10)是创建p的同时，对p指向的值初始化
		（3）在delete完对象后，记得p=NULL，防止出现野指针
		
~&：引用的用法
	1）作用：给变量起别名
	2）本质：常量指针
	3）语法：int &a1=a;
	4）注意：
		（1）引用一定要初始化
		（2）初始化之后就不可以定义为其余变量的别名
		（3）形参为引用时，也可以更改实参的值，节省内存开销
		
~函数形参默认值相关：
	1）示例：int fun(int a,int b=10,int c=20)
	           {
				...
			   }
	2）注意：
		（1）如果我们在调用函数时，自己传参就用自己的数据，如果没有就用默认值
		（2）如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值
		（3）函数声明和函数定义只能默认一次
		
~C++面向对象三大特性：
	封装	继承 	多态
	
~封装的意义：
	1）将成员变量/成员属性和成员函数/成员方法定义在一起
	2）权限控制：可以隐藏对外提供的接口的具体实现方式
		public：	公共权限，类内可访问，类外可访问，友元可访问，可被继承访问
		private:	私有权限，类内可访问，类外不可访问，友元可访问，不可被继承访问
		protected:	保护权限，类内可访问，类外不可访问，友元可访问，可被继承访问

~C++中struct和class区别：唯一区别就是默认权限不同
	·struct：默认public
	·class:	 默认private

~c语言中struct与c++中struct有何区别：
	1）在实例化对象时，c语言前需要加struct关键字
	2）c语言没有面向对象的三大特性：
		（1）无成员函数，无权限管理
		（2）无继承
		（3）五多态
	
~成员属性设置私有的目的：
	1）可以自己控制成员变量的读写权限
	2）写数据时可以检测数据的有效性

~构造函数：
	1）作用：创建对象时初始化对象
	2）特点：
		（1）无返回值，也不写void
		（2）函数名称与类名相同
		（3）有参数，可以发生重载
		（4）在创建对象时由编译器自动调用，且只调用一次
		
~析构函数：
	1）作用：销毁对象前对成员属性的内存进行清理
	2）特点：
		（1）无返回值，也不写void
		（2）函数，在名称前加~
		（3）无参数，不可以发生重载
		（4）对象销毁前由系统自动调用，且只调用一次

~构造函数分类：
	1）无参构造函数
	2）有参构造函数
	3）拷贝构造函数：参数书写格式：类名 &形参对象名，一般用const修饰
		
~构造函数的调用方法：
	1）默认构造函数的调用（无参）：	
		Person p;
	2）匿名对象（有参）：	
		Person(10)
		说明：
			（1）当前行执行完，系统立刻回收掉匿名对象
			（2）不要使用拷贝构造函数初始化匿名对象，因为Person(p1) === Person p1,会被编译器认为是重复定义
	3）括号法（有参/拷贝）：
		Person p1(10);
		Person p2(p1);
	4）显示法（有参/拷贝）：
		Person p1=Person(10);
		Person p1=Person(p1);
	5）隐式转换法（有参/拷贝）：
		Person p1=10;
		Person p2=p1;
		
~拷贝构造函数的调用时机：
	1）使用已经创建好的对象来初始化一个新的对象
	2）值传递的方式给函数传参
	3）值方式返回局部对象
	
~构造函数的调用规则：
	1）默认有无参构造函数和拷贝构造函数
	2）有参构造函数若要使用只能自定义
	3）若定义了有参或者拷贝构造函数，无参构造函数一定要重新定义
	
~深拷贝与浅拷贝
	1）浅拷贝：简单的赋值拷贝操作
	2）深拷贝：在堆区重新申请空间，进行拷贝操作
	
~初始化列表：用来初始化属性，为初始化提供另一种简单写法
	1）传统写法：
		Person(int a)
		{
			age=a;
		}
	2）初始化列表写法：
		Person(int a):age(a)
		{
		
		}
			
~类作为另一个类的成员
	·例：
		class A
		{
		public:
			int num1;
		}
		
		class B
		{
		public:
			A a;
			int num2;
			
			B(int n1,int n2)
			{
				a.num1=n1;
				num2=n2;
			}
		}
	·注意：
		1）赋初值时，B有参构造函数的写法是：A和B所有的属性作为参数
		2）先构造A，后构造B
		
~静态成员变量：
	1）类内声明：static int a；
	   类外定义（赋初值），且必须赋初值：int A::a=10;
	2）访问方式（public）：
	   （1）类名::变量名
	   （2）对象名.变量名
	3）所有对象共享一份数据
	4）在编译阶段分配内存
	
~静态成员函数：
	1）所有对象共享同一个函数
	2）静态成员函数只能访问静态成员变量
	3）访问方式：
		（1）类名::函数名
		（2）对象名.函数名

~类对象的空间内存占用：
	1）空对象占1
	2）非空对象：成员变量与成员函数分开存储
		（1）非静态成员变量内存空间在对象上
		（2）静态成员变量内存空间在类上，编译阶段分配。
		（3）非静态成员函数内存空间不在对象/类上
		（4）静态成员函数内存空间不在对象/类上
	
~this指针概念
	1）为什么用this:
		因为每一个非静态成员函数只会诞生一份函数实例，也就是说，多个同类型的对象会公用一块代码，
		this指针就可以区分是当前对象调用的自己，也就是说this指针指向被调用的成员函数所属的对象
	2）this特性：
		（1）this指针是隐含在每一个非静态成员函数内的一种指针
		（2）this指针不需要定义，直接使用
	3）this用途：
		（1）区分形参和成员函数同名问题
		（2）在类的非静态成员函数中返回被处理后的对象本身，可以使用return *this；
	
~const修饰成员函数，对象
	1）常函数：
		（1）在成员函数后加const，我们称此函数为常函数
		（2）常函数只能更改mutable修饰的成员变量
	2）常对象：
		（1）声明对象前加const，我们称此对象为常对象
		（2）常对象只能更改mutable修饰的成员变量
		（3）常对象只能访问常函数
	3）注意：
		（1）this指针本质上是指针常量
		（2）const本质上修饰的是this指针

~mutable的作用：
	使得常函数和常对象可以访问其修饰的成员变量

~成员函数在类外定义的格式：
	返回值类型  类名::成员函数名(参数列表...)
	{
		...
	}
	
~友元：
	1）目的：让全局函数或类访问另一个类中的私有属性
	2）关键字：friend
	3）三种实现方式：
		（1）全局函数做友元
			·例：全局函数void fun()想访问A类中私有成员
			·做法：在A类中写friend void fun();
		（2）类做友元
			·例：类B中所有成员函数想要访问A类中私有属性
			·做法：在A中写friend class B;
		（3）成员函数做友元：
			·例：类B中成员函数void fun()想访问A类中私有属性
			·做法：在A中写friend void B::fun()
	4）注意：
		（1）除了构造函数，析构函数，类的其余成员函数尽量类外定义，这样方便类的声明与调用其余类的成员
		（2）B的声明要在A前，否则A中无法写friend void B::fun();
	
~运算符重载:A.operator+(B) === A+B
	1）概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
	2）本质：就是自定义了一个功能函数来实现相应的功能，之后又命名为编译器所起的通用名称，这样在调用时便可以
	         简写为我们常见的形式
	3）实现方式：
		（1）类内成员函数实现：只能在运算符左侧类（调用方）中定义
		（2）类外全局函数实现：可以自定义运算符两边的对象顺序
	4）注意：如果返回值类型为运算符左侧（调用方）类型，可以实现链式编程
	
~继承：
	1）意义：减少重复代码
	2）语法：class 子类/派生名:继承方式 父类/基类名
	3）继承的方式：public/protected/private
		（1）继承的本质就是子类拥有父类所有的成员
		（2）继承之后，子类中private成员无法访问
		（3）public继承：   不会更改父类中成员的权限
		     proected继承： 将public成员更改为protected权限
			 private继承：  将public成员以及protected成员权限更改为private
			 
~继承中父类与子类的构造与析构顺序
	1）先构造父类后构造子类
	2）先析构子类后析构父类
	
~继承中同名成员函数处理方式：
	1）访问子类同名函数，直接访问即可
	2）访问父类同名成员，加作用域
	3）如果子类中出现和父类同名的成员函数，子类的同名函数会隐藏掉父类中所有的重载函数

~重载函数：
	1）函数名相同，参数不同（个数，类型，顺序）
	2）不可以通过函数返回值不同判断是否发生了重载
	
~多态
	1）分类：
		（1）静态多态：函数重载和运算符重载，复用函数名
		（2）动态多态：派生类和虚函数实现运行时多态
	2）静态与动态区别：
		（1）静态多态的函数地址早绑定-编译阶段确定函数地址
		（2）动态多态的函数地址晚绑定-运行阶段确定函数地址
	3）动态多态满足条件：
		（1）有继承关系
		（2）子类重写父类的虚函数
	4）动态多态的使用条件
		（1）自定义函数时，以父类对象的引用或指针为形参，函数体内部对父类的虚函数进行一系列操作
		（2）父类的指针或引用指向子类的对象，也就是说传参时传入的是子类对象，那么函数体内部对虚函数的操作
		     就更改为对子类中重写函数的操作
	
~多态的优点/缺点：
	1）优点：
		（1）代码组织结构清晰
		（2）可读性强
		（3）利于前期和后期的扩展以及维护
	2）缺点：代码量可能增加
