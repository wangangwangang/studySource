~查fun()函数依赖库：man -a fun

~详谈printf()
	1.printf("");没有立刻输出到标准输出（stdout），只是输出到用户的缓冲区
	2.何时缓冲区的内容被输出到标准缓冲区
		（1）缓冲区满
		（2）\n 
		（3）fflush(stdout)	将输出缓冲区内容刷新到终端

~setbuf(stdin,NULL):清空输入缓冲区

~保留控制台，使得输出内容不被闪退
	linux下：
		1）printf("信息\n");
		   setbuf(stdin,NULL);
		   getchar();
	windows下:
		1）printf("信息\n");
		   system("pause");

~什么是段错误：段错误就是程序尝试访问一段不可访问的内存

~c语言中全局变量的跨文件使用
		使用extern关键字来声明变量为外部变量。具体说就是在其中一个c文件中定义一个全局变量key，
	然后在另一个要使用key这个变量的c文件中使用extern关键字声明一次，说明这个变量为外部变量，
	是在其他的c文件中定义的全局变量。请注意我这里的用词：定义和声明。例如在main.c文件中定义变量key，
	在common.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了。
	
	示例：
	（1）main.c文件
	#include "common.h"
	unsigned char key;

	（2）common.c文件：
	#include "common.h"
	extern unsigned char key;
	
~将结构体变量传参，在自定义函数中改变结构体元素值，不会影响实参中结构体的元素值

~关于头文件包含
	1）#include <***.h>：代表在标准头文件路径中查找
	2）#include "***.h"：代表在指定路径（如果没有目录，默认当前目录）中查找，如果找不到，再到标准头文件目录中查找
	3）如果***.h文件不在现有标准头文件路径中，仍然写为#include <***.h>，可以用-I扩充头文件路径
	   gcc  ***.c  -I<***.h文件所在的路径>
		
~如何设置标准头文件目录
	1.添加编译选项
	  gcc demo.c -o demo  -I/tools/libevent/include 
		-I：头文件目录
	2.如果想简单点，就在/etc/profile添加
		C_INCLUDE_PATH=/tools/libevent/include:$C_INCLUDE_PATH
		export C_INCLUDE_PATH

~预定义宏
	1）__LINE__		行号
	2）__FILE__		本文件名
	3）__DATE__		日期（格式：月 日 年）
	4）__TIME__		时间（格式：时：分：秒）
	5）__func__		当前函数名

~位运算
	1）按位与运算：&
		（1）基本运算：0&0=0 0&1=0 1&1=1
		（2）总结：1为相同，0为置零，因此与运算多用于按位置零
	2）按位或运算：|
		（1）基本运算：0|0=0 0|1=1 1|1=1
		（2）总结：0为相同，1为置1，因此或运算多用于按位置1
	3）按位异或运算：^
		（1）基本运算：0^0=0 0^1=0 1^1=0
		（2）总结：0为相同，1为取反，因此异或运算多用与按位取反
	4）求反运算：~
	5）左移运算：<<
	6）右移运算：>>
	示例：	（1）a&( ~(1<<5) )		将第6位清零（从右往左边数第六个）
			（2）a&( ~(0xf<<5) )	将第6、7、8、9位清零
			（3）a|( 1<<5 )			将第6位置1
			（4）a|( 3<<5 )			将第6、7位置1
			（5）a^( 1<<5 )			将第6位取反
			（6）a^( 3<<5 )			将第6、7位取反
			
~C语言内存区间分配
	1）栈区（stack）   
		·内容：存放函数的形参，auto局部变量，const局部常量
		·管理：使用时由编译器自动分配，函数结束或循环体结束释放
	2）堆区（heap）    
		·内容：由程序员管理的空间，可以存放任意数据
		·管理：在使用时由程序员分配，在任意位置不使用了由程序员释放，（malloc-free,new-delete），如果程序员不释放，程序结束时由OS回收
	3）全局区（静态区）（static）
		·内容：存放全局变量，static静态变量，const全局常量，字符串常量
		·管理：使用时由操作系统分配，程序结束由操作系统释放
	4）代码区
		·内容：存放二进制代码，存放CPU执行的机器指令
		·管理：（1）生成可执行程序时由操作系统分配，在删除可执行程序时由操作系统释放
		       （2）代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
			   （3）代码区是只读的，目的是防止被程序意外修了指令
		
	
~内存分区的意义
	不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

~C语言变量属性
	1.作用域
	2.链接属性
	3.生命周期

~函数传参的三种方式
	传值
		1）优点是修改形参值不改变实参
		2）缺点时被调用函数处理的数据为复制过去的数据，内存开销大
	传址
		1）传址调用的优点是节省内存开销
		2）传址调用的缺点是可以改变指向的变量的值，当然如果希望更改实参值另当别论
	传引用
		1）引用本质上就是指针常量，引用的值就是实参的别名，也有节省内存开销的优点
		2）相较于指针更加安全，引用一定初始化了

~引用的作用
	1）首先引用本质上是指针常量，指针的指向不变，但是指向的值可以改变
	2）作用就是给变量取个别名
	3）引用一定要初始化，因此比指针安全，指针在使用时需要判断是否为NULL

~c中const作用
	1）定义常量，与#define宏定义作用相仿
	2）再函数传参时修饰参数，可以防止参数在函数运行过程中被更改
	3）定义指针常量/常量指针，从左到右，const离谁近，谁就不能被修改；
		int const  * ptr;        常量指针：指向常量的指针
		int * const  ptr;		 指针常量：指针类型的常量

~C语言中static关键字的作用
	1）延长了局部变量的生命周期，直到程序运行结束之后才释放
	2）修饰了全局变量的链接属性，只能在本文件中使用，不能在其他文件中使用，即便是有extern外部声明也不可以
	3）修饰了函数的链接属性，只能在本文件中被调用，不能被其他文件调用
	
	总结用途：（1）变量空间不想被释放。比如修饰函数中存放在栈空间的数组，如果不想在函数结束时被释放，可以用static修饰
			  （2）考虑到数据安全性。使用全局变量时应该优先考虑使用static
			  
~C++中static关键字的作用
	1）具有C语言中所有作用
	2）静态数据成员：
		（1）静态数据成员可以实现多个对象之间的数据共享，他是类的所有对象的共享成员，他在内存中只占一份空间，如果
			 改变它的值，则各对象中这个数据成员的值都被改变
		（2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义
		     对象，也会为静态数据成分分配空间
		（3）静态数据成员可以被初始化，但只能在类外进行初始化，若未对静态数据成员赋初始，则编译器会自动为其初始化为0
		（4）静态数据成员既可以通过对象名引用，也可以通过类名引用
	3）静态成员函数
		（1）静态成员函数与静态数据成员一样，他们都属于类的静态成员，而不是对象成员
		（2）非静态成员函数有this指针，而静态成员函数没有this指针
		（3）静态成员函数主要来访问静态数据成员，而不能访问非静态数据成员

~三方库文件：就是已写好的功能函数的这类文件，可以直接被我们写的main.c文件依赖，在编译链接的时候参与生成可执行文件，
			 比如说memcached库

~枚举型变量(enum)：
	1）默认从0开始，之后依次加1
 
~sizeof/strlen
	1）sizeof：运算符，计算的是字符串或者各种类型数组占用的字节数，（包含'\0'）		(统计数据类型所占内存大小)				       
	2）strlen：函数，计算的是字符串实际长度，遇'\0'结束计算，（不包含'\0'）
	
	参考代码：
		char a[10]={'a','b'};
		int  b[10]={1,2,3};
		
		printf("%d\n",sizeof("12345"));				6
		printf("%d\n",strlen("12345"));				5
		printf("%d\n",sizeof(a));					10
		printf("%d\n",strlen(a));					2
		printf("%d\n",sizeof(b));					40
		printf("%d\n",strlen(b));					1
		


	
~注释符
	1）//
	2）/*
		... 	
			*/

~数据类型
	1）基本类型
		char	字符型			1字节					无符号（0 ~ 2^8-1）,有符号（-2^7 ~ 2^7-1）
		short	短整型			2字节		
		int		整形			4字节					无符号（0 ~ 2^32-1）,有符号（-2^31 ~ 2^31-1）
		long	长整型			32位4字节，64位8字节
		float	单精度浮点型	4字节
		double	双精度浮点型	8字节
	2）构造类型
		数组：
		指针：无论什么类型的指针：32位4个字节，64位8个字节
		结构体：
		共用体：
	

~转义字符
	\b		退格符
	\t		水平制表符
	\n		换行符

~输出格式符
	%c		字符型
	%s		字符串型
	%d		整型
	%ld		长整型
	%lu		无符号长整型
	%f		单精度浮点型
	%lf		双精度浮点型
	%p		打印地址
	
~浮点型表示方法
	1）2.3   12.45
	2）2E-2 = 0.02  12E-4 = 0.0012
	注意：（1）E的左边必须有数据，整型或者浮点型
		  （2）E的右边必须有数据，整型
		  
~变量的命名规则
	1）变量名由字母，数字和下划线（_）组成
	2）字母不能由数字开头
	3）C语言中的某些词（例如：int char...）称为保留字，具有特殊意义，不能作为变量名
	4）C语言变量区分大小写
	
~变量使用注意事项
	1）变量如果没有赋初值，就不能将其赋值给其他变量
		示例：int n,m;
			  m=n;
	
~变量的属性
	1）作用域：
		文件作用域/函数作用域/代码块作用域/原型作用域（用于函数声明）
	2）链接属性：
		（1）内部链接属性：不同文件同一变量不是同一个变量
		（2）外部链接属性：不同文件同一变量是同一个变量
		注意：局部变量：无链接属性
			  全局变量：有extern	外部链接属性（也是默认链接属性）
						有static	内部链接属性
	3）存储属性：
		（1）静态存储属性：变量在定义的时候就分配好空间（不可恢复）
		（2）动态存储属性（栈）：变量在使用时分配空间，使用后释放（可恢复）
		注意：全局变量：全部为静态存储属性
			  局部变量：有static为静态，变量只初始化一次
						无static为动态
	4）生命周期：

~运算符
	优先级：单目运算符>算数运算符>关系运算符>逻辑运算符>条件运算符>赋值运算符>逗号运算符
	1）单目运算符：++ -- sizeof !
	2）算数运算符：+ - * / %
	3）关系运算符：> >= < <= = != ==
	4）赋值运算符：= +=
	5）逻辑运算符：|| && ！
	6）条件运算符：?:
		示例：max=a>b?a:b		条件为真将：左边赋给max，条件为假将：右边赋给max

~if-else条件语句
	if()
	{
		...
	}
	else
	{
		...
	}
	注意：1）else总是配套前面最近的if
		  2）如果if后不加{}，则默认只有接下来一行语句执行if条件

~switch-case语句
	switch(表达式)
	{
		case 常量1:
				{
					...
					break;
				}
		case 常量2:
				{
					...
					break;
				}
		...
		default:
				{
       				...
				}
	}
	注意：1）在case后的各常量值不能相同
		  2）在case后允许有多个语句，可以不用{}，因为之后有break
		  3）每个case后必须要有break，否则产生穿透，一直向下运行，直到遇见break或者执行结束
		  4）各个case和default子句的先后顺序可以变动，不影响结果
		  5）default子句非必须存在
		  
~while循环结构
	while(循环条件)
	{
		循环体...
	}
	注意：1）循环条件中变量需要经过初始化
		  2）循环体中语句一般要修改循环条件的值，而且是趋向使条件为假，否则会形成死循环
		  
~do-while循环结构
	do
	{
		循环体...
	}while(循环条件);
	注意：while是先判断循环条件后执行循环体
		  do-while是先执行循环体后判断循环条件
		  
~for循环结构
	for(变量初始化;循环条件;变量更改表达式)
	{
		循环体...
	}

~一维数组
	1）作用：当定义同一种变量比较多时，选择用数组
	2）注意：（1）数组中元素必须是同一种类型
			 （2）数组中元素在内存上是连续的
    3）数组的几种初始化情况
			 （1）a[3]={1,2,3,4}		错误，越界
			 （2）a[]={}				错误，既没有说明长度，也没有赋值
			 （3）a[3]={1,2,3}			正确
			 （3）a[3]={1}				正确
			 （4）a[]={1,2,3,4}			正确
		注意：（1）[]{}不能都没有值
			  （2）[]有值时，{}只要满足不越界就可以
			  （3）[]无值时，{}中必须有值
			  
~二维数组
	1）初始化原则
		（1）不越界
		（2）只能省略第一维长度，不能省第二维长度，并且花括号内必须有元素
		
~指针的概念
	1）指针是一个变量，存储的是一个对象的内存地址
	2）如果一个变量存储另一个对象的地址，则称该变量指向这个对象
	3）指针指向在程序运行过程中可以更改
	4）指针只能指向同种类型的变量
	5）指针必须初始化地址之后才能赋值
	
	
~指针的使用
	1）定义：int  *p1,*p2,a=1,b=2;
	2）初始化：p1=&a,p2=&b
	3）指针的使用：*p1=*p2  p1的指向未变，但是指向的变量值改变了
				   p1=p2    p1的指向发生了改变 
	4）指针之间的减法可以判断高低指针：p1-p2=-1说明p2在p1之后
	
~指针的四个方面
	1）指针的类型
	2）指针指向对象的类型
	3）指针的值
	4）指针指向对象的值

~指针的定义方式
	1）int * fp;
	2）int*  fp;
	3）int  *fp;
	
~指针初始化为空
	int *fp=NULL;

~指针指向数组的应用
	示例：int	a[n];
	1）地址法：a+i==&a[i]  
			   *(a+i)==a[i]
			   a[i][j]==*(*(a+i)+j)
	
~指针数组
	1）首先是一个数组
	2）数组的元素是指针
	3）用法：int* a[n]
	
	
~数组指针
	1）首先是一个指针
	2）指针指向一个数组
	3）用法：int (*a)[n]
	
~字符串的赋值
	1）char c[5]="1234"   ##注意：最多有四个元素，还有一个默认的'\0'尾符，尾符也占一个字节
	2）char c[5]={'1','2'.'3','4','\0'}
	3）*p="1234"
	
~函数机制的优点
	1）使程序变得更简短而清晰
	2）有利于程序维护
	3）可以提高程序开发的效率
	4）提高了代码的重用性

~内置函数
	1）由C语言系统提供
	2）用户无须定义，也不必在程序中做类型说明
	3）只需要在程序前包含有该函数定义的头文件
	

~<string.h> 字符串函数库
	strlen()：计算字符串长度
		1）作用：
		2）用法：
		
	strcpy()：
		1）作用：字符串复制
		2）用法：strcpy(str1,str2);
		3）含义：将str2字符串复制到str1中
		注意：（1）str1不能小于str2
		
	strncpy()：
		1）作用：字符串复制
		2）用法：strcpy(str1,str2,n);
		3）含义：将str2字符串的前n个字符复制到str1中
		
		
	strcmp()：
		1）作用：字符串比较
		2）用法：strcmp(str1,str2);
		注意：（1）返回值大于0，str1靠前的字符大于str2靠前的字符
				   返回值等于0，str1靠前的字符等于str2靠前的字符
				   返回值小于0，str1靠前的字符小于str2靠前的字符
			  （2）比较方式，逐字符比较
		
	strncmp()：
		1）作用：字符串比较
		2）用法：strncmp(str1,str2,n);
		3）含义：比较str1和str2的前n个字符
		注意：（1）返回值为ASCII码值差值
				   返回值大于0，str1的前n个字符大于str2的前n个字符
				   返回值等于0，str1的前n个字符等于str2的前n个字符
				   返回值小于0，str1的前n个字符小于str2的前n个字符
				   
			 	
		
	strcat()：
		1）作用：字符串连接
		2）用法：strcat(str1,str2);
		3）含义：将str2连接到str1后面
		
	
	strncat()：
		1）作用：字符串连接
		2）用法：strncat(str1,str2,n);
		3）含义：将str2的前n个字符连接到str1后面	

	memcpy()：
		1）作用：内存区复制
		2）用法：memcpy(str1,str2,n);
		3）含义：将str2的前n个内存复制到str1里

	memset()：
		1）作用：数组清空置零
		2）用法：memset(str,0,sizeof(str));

~memcpy与strcpy/strncpy的区别
	1）strcpy/strncpy是内容复制，一般来说只能复制字符串
	2）memcpy是内存复制，可以复制任意内容，例如字符数组、整型、结构体、类等。

~<math.h> 					##注意：在编译时，需要在末尾加上-lm
	double sqrt(double x)
		1）作用：计算方根
		2）用法：sqrt(9);
	
	double pow(double a,double b)
		1）作用：计算幂
		2）用法：pow(2,3);
		3）含义：计算2的3次方
	
~<stdio.h>

~<stdlib.h>
	rand()
		1）作用：取随机值
		2）用法：rand()%n;
		3）含义：在0~n-1间取随机值
		注意：（1）解决多次执行文件时，产生同一套随机值：
						添加头文件<time.h>
						在rand()函数前加：srand((unsigned) time(NULL));
	

~函数指针
	1）首先是一个指针，指针指向某一类函数
	2）用法：int (*P)(形参1，形参2){}
	3）含义：指针指向一类返回值为int，有两个形参的函数
	注意：（1）指向函数的指针没有自增自减运算，指向变量的指针有
	
~指针函数
	1）首先是一个函数，函数的返回值是一个指针
	2）用法：int* p(形参1，形参2){}
	
	
~argc和argv的用法：main函数参数
	示例：int  main(int argc,char *argv[])
		  {			
			printf("argc=%d\n",argc);
			
			int i;
			for（i=0;i<argc;i++）
			{
				print("argv[%d]=%s\n",i,argv[i]);
			}
			
			return 0;
		  }
	1）argc是一个整型变量，代表命令行参数的个数（包括可执行文件名）
	2）argv是一个指针数组，数组元素是指向各个参数的指针（argv[0]是可执行文件名，argv[n]就是第n个参数）
		  
~结构体的定义
	1）C语言为了存储不同类型的数据，进而引入了称为结构的数据存储方式
	2）"结构"是一种构造数据类型，它是由若干数据项组合而成的复杂数据对象，这些数据项称为结构的成员
	
~结构体使用步骤
	1）结构体类型的定义及结构体变量定义
		（1）方法一：先定义结构体类型，有结构体名，之后定义结构体变量
		struct stu
			{
				int		num;
				char 	name[20];
				char 	sex;
				float 	score;
			};
		struct stu  stu1,stu2;
		（2）方法二：定义结构体类型的同时也定义结构体变量，有结构体名，之后也可以定义结构体变量
		struct stu
			{
				int		num;
				char 	name[20];
				char 	sex;
				float 	score;
			}stu1,stu2;
		struct stu  stu3,stu4;
		（3）定义结构体类型的同时也定义结构体变量，没由结构体名，之后不可以定义别的结构体变量
		struct 
			{
				int		num;
				char 	name[20];
				char 	sex;
				float 	score;
			}stu1,stu2;

	3）结构体的初始化
		1）struct stu stu1={1,"zhangsan",'m',78.5};
		2）stu1.num=1;
		   strcpy(stu1.name,"zhangsan");
		   stu1.sex='m';
		   stu1.score=78.5;
	4）结构体元素的调用
		printf("num=%d\n",stu1.num);

~结构体指针	
	1）指向结构体变量的指针
	2）定义：struct stu *p;
	3）使用：p=&stu1;
			 p->num=2;
			 ++p->num;   ##注意：->优先级高于++

~结构体内存占用
	1）结构体字节对齐数=结构体成员占用最大的字节数
		char	1字节
		short	2字节
		int		4字节
		float	4字节
		double	8字节
	2）按照结构体成员定义的顺序分配字节，统计分配了多少次，最后求出字节总数
		
~共用体（union）
	1）所有成员共用内存的同一区间
	2）共用体的长度是共用体最长成员的长度
	3）共用体变量初始化必须是共用体的第一个成员类型值

~结构体和共用体的区别
	1）结构体的各个成员会占用不同的内存
		（1）互相之间没有影响
		（2）结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙）,具体算法依照字节对齐原则
	2）共用体的所有成员占用同一段内存
		（1）修改一个成员会影响其余所有成员，共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。
		（2）共用体占用的内存等于最长的成员占用的内存。
	
~typedef用法
	1）作用：给已有的数据类型起一个别命
	2）用法：typedef <已有数据类型>  <新定义数据类型>;
	   示例：typedef int INT;
	注意：需要在末尾加";"

~#define宏替换用法
	1）作用：可以提高程序的可维护性，可移植性，减少程序中重复书写字符串的工作量
	2）用法：#define <宏名>  <替换的内容>
		     示例：#define  PI  3.1415926
	注意：
		（1）"define"是宏定义关键字，前面加上"#"就是一条预处理命令
		（2）在#define，宏名，替换的内容之间用空格隔开
		（3）宏名一般用大写字母表示，便于与变量名区别，当然原则上也可以用小写字母
		（4）宏定义是用宏名代替一个字符串，只做简单替换，不做任何语法等正确性与否检查，只在编译时报错
		（5）不需要在末尾加";"
		（6）宏定义一般写在函数之外，其作用域从宏定义命令起到源程序结束。如果要终止其作用域，用#undef
		（7）对程序中用""括起来的宏名，不进行替换
			 示例：#define PI 3.1415926
				   printf("PI \n");
		（8）在宏定义时，可以引用已经定义的宏名
		（9）#define也可以替换数据类型
			 示例：#define INT int
		（10）替换的内容可以是变量，表达式等
		（11）宏定义与变量定义不同，不分配内存空间
		（12）带参数的宏定义，只是将语句中宏名中的参数，简单替换到替换内容中
			  示例：#define S(r)  PI*r*r
					S(a+b)=PI*a+b*a+b
					
					#define S(a,b) a*b
					S(3,4)=3*4
					
		（13）严格控制空格的使用
			  示例：#define S (r) PI*r*r
					S (2)=(r) PI*r*r (2)
		（14）宏名不能用关键字
			  示例：#define int 3.1415926
			  
~文件按编码分类
	1）ASCII码文件
		ASCII码文件也称文本文件，这种文件在磁盘中储存时每个字符对应一个字节，存放的是对应字符的二进制ASCII码值
		示例：1 2 3 4   00110001  00110010 00110011  00110100  
	2）二进制文件

-----------------------------------------------------------文件操作-------------------------------------------------------
~文件指针
	1）概念：在C语言中用一个指针变量指向一个文件，这个指针称为文件指针
	2）作用：通过文件指针就可以对它所指的文件进行各种操作
	3）文件指针变量的定义
		FILE *pf;
	注意：FILE实际上是由系统定义的一个结构，该结构中含有文件名，文件状态和文件当前位置等信息



【C/API接口函数】
~open()：打开文件
	1.依赖库：<sys/types.h> <sys/stat.h> <fcntl.h>
	2.原型：int open( const char *pathname,			文件路径字符串
				      int flags)					文件操作方式：O_RDONLY/只读  
																  O_WRONLY/只写
																  O_RDWR/读写
																  O_APPEND/追加

~write()：写文件
	1.依赖库：<unistd.h>
	2.原型：ssize_t write( int fd,				文件描述符
						   const void *buf,		从哪里获取写的数据
						   size_t count);		获取多少数据

~read()：读文件
	1.依赖库：<unistd.h>
	2.原型：ssize_t read( int fd,				文件描述符
						  const void *buf,		读到哪里去
						  size_t count);		读的地方预留了多少空间
						  
~close()：关闭文件
	1.依赖库：<unistd.h>
	2.原型：int close(int fd);					参数是文件描述符
	
	

	
~fopen()：打开文件
	1.依赖库：<stdio.h>
	2.原型：FILE *fopen(const char *path,		文件路径字符串
						const char *mode)		文件打开模式自负串
	3.返回值：文件描述符地址（FILE类型指针）
	3.注意：（1）把一个文件读入内存时，要将磁盘文件中对应的ASCII码值转化成二进制码，把内存中二进制数据以文本文件形式写入磁盘时，要将内存中的二进制转化成ASCII码
			 (2）标准输入文件（stdin），标准输出文件（stdout）,标准出错文件（stderr）是由系统打开的，可直接使用
					
~文件打开模式
	r		文本文件		读			文件必须存在
	w		文本文件		写			文件不存在则新建，文件存在就先删除再新建
	a		文本文件		追加		文件必须存在
	rb		二进制文件		读			文件必须存在
	wb		二进制文件		写			文件不存在则新建，文件存在就先删除再新建
	ab		二进制文件		追加		文件必须存在
	r+		文本文件		读和写		文件必须存在
	w+		文本文件		读和写		文件不存在则新建，文件存在就先删除再新建
	a+		文本文件		读和追加	文件必须存在
	rb+		二进制文件		读和写		文件必须存在
	wb+		二进制文件		读和写		文件不存在则新建，文件存在就先删除再新建
	ab+		二进制文件		读和追加	文件必须存在
	注意：	t(text)文本文件		b(banary)二进制文件		+读和写

~getc()/putc()

~fgetc()/fputc()
	fgetc()
	1）功能：从指定文件读一个字符
	2）用法：ch=fgetc(fp);
	3）含义：从打开的文件中读取一个字符
	注意:（1）文件以读或读写方式打开
		 （2）每读一个字符，文件内部位置指针向后移动一个字符
		 （3）读取字符的结果也可以不赋值，例如：fgetc(fp);
		 （4）fgetc()函数有返回值，成功返回读入的字符，否则返回一个EOF

    fputc()
	1）功能：把一个字符写入文件
	2）用法：fputc('a',fp);
	3）含义：把字符a写入fp指向的文件
	注意：（1）文件以写，读写或追加方式打开
		  （2）每写一个字符，文件内部位置指针向后移动一个字符
		  （3）fputc()函数有返回值，成功返回写入的字符，否则返回一个EOF

	
~scanf()/printf()
	scanf()
	1）作用：从键盘按格式读取
	2）用法：scanf("%d%d",&a&b);
	注意：（1）默认空格/回车符为分隔符,不读取空格/分隔符
	
	printf()
	1）作用：向终端按格式输出
	2）用法：pritnf("%d%d",a,b);
	注意：（1）不自动换行
	
~fscanf()/fprintf()
	fscanf()
	1）作用：从文本文件按格式读取
	2）用法：fscanf(fp,"%d%d",&x,&y);
	注意：（1）fscanf(stdin,"%d",&a);等价于scanf("%d",&a);
		  （2）默认空格/回车符为分隔符,不读取空格/分隔符

	fprintf()
	1）作用：按格式写入文本文件
	2）用法：fprintf(fp,"%d%d",x,y);
	注意：（1）fprinf(stdout,"%d",a);等价于printf("%d",a);
		  

~gets()/puts()
	gets()
	1）作用：从键盘中读取字符串
	2）用法：gets(str);
	注意：（1）函数有BUG，在编译时报警
		　（2）默认回车为分隔符，读取空格，不读取回车

	fputs()
	1）作用：向终端输出字符串
	2）用法：puts(srt);
	注意：（1）字符串可以是字符串常量，也可以是字符数组名或字符指针变量
		  （2）自动换行
		  
		  
~fgets()/fputs()
	fgets()
	1）作用：从文件中读取字符串
	2）用法：fgets(str,n,fp);
	3）含义：从fp指向的文件中读入n-1个字符到字符数组str中，再在读入的最后一个字符后加上'\0'
	注意：（1）吸收空格吸收回车，无默认分隔符
	
	fputs()
	1）作用：向文件写入字符串
	2）用法：fputs("abcd",fp);
	3）含义：将字符串"abcd"写入文件
	注意：（1）字符串可以是字符串常量，也可以是字符数组名或指针变量
		  （2）成功写入一个字符串后，文件的位置指针自动后移
		  （3）成功返回一个非负整数，失败返回EOF
		  
		  
~fread()/fwrite()
	fread()
	1）作用：从文件中读取数据块
	2）用法：fread(buffer,size,count,fp);
	注意：（1）buffer是存放读取数据位置的首地址
		  （2）size是数据块字节数
		  （3）count是数据块数目
		  （4）每调用一次函数，读取数据大小为(size * count) 

	fwrite()
	1）作用：向文件写入数据块
	2）用法：fwrite(buffer,size,count,fp);
	注意：（1）buffer是需要写入的数据的首地址
		  （2）size是数据块字节数
		  （3）count是数据块数目
		  （4）每调用一次函数，写入数据大小为(size * count) 

~rewind()
	1）功能：在文件处理的过程中，把文件的读写位置指针移动到文件的开头
	2）调用：rewind(fp);
	3）含义：将fp指向的文件的内部文件指针移动到文件的开头，以后文件的读写操作就从文件开头开始
	
~fseek()
	1）功能：用来移动文件内部指针到指定位置
	2）用法：fseek(fp,位移量,起始位置)
	3）"位移量"：指位置指针移动的字节数，要求位移量是long型数据，以便在文件长度大于64KB时不会出错，可以为负数。
	4）"起始位置"：三种情况
	   文件首部		SEEK_SET		0
	   当前位置		SEEK_CVR		1
	   文件尾部		SEEK_END		2
	5）fseek()一般用于二进制文件   

~函数基本概念
	1）一个C语言程序由一个或多个.c文件组成
	2）.c文件由多个函数定义组成
	3）在多个函数定义中有且仅有一个main()函数，main()函数是c语言程序的入口
	
~函数的三个基本方面
	1）函数定义
		返回值类型  函数名(形参1类型 形参1名,形参2类型 形参2名)
		{
			函数体...
		}
	2）函数声明
		（1）在同一个文件开头声明
		（2）在.h文件中声明
		（3）声明方式：返回值类型  函数名(形参1类型 形参1名,形参2类型 形参2名);
	3）函数使用
		（1）形参和实参需要满足数目相同，次序对应以及类型一致的条件
		（2）形参只有函数调用时才会被分配内存，调用结束后立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外使用
		
				

~return的用法
	1）一个函数最多有一个return值
	2）只要遇到return立刻退出当前函数
	3）如果函数需要有返回值，则一定需要return来将值返回

~回调函数
	1）就是一个通过函数指针调用的函数，如果你把函数的指针作为参数传递给另一个函数,当这个指针被用来调用其指向的函数，我们就说这是回调函数
	2）用来封装函数
	3）当一组参数需要被不同函数（同种类型）处理时，我们需要创建一个封装函数
	实例：int Hd(int a,int b)         //这个就是回调函数
		  {
				...
		  }
		  
		  int FUN(int a,int b,int (*p){int c,int d})    //这个是封装函数
		  {
				return p(a,b);
		  }
		  
		  int main()
		  {
				int a=1,b=2;
				return FUN(1,2,Hd);                    //封装函数调用回调函数，函数名就是指向这个函数的指针
				
		  }

~fun.h文件的创建格式
	#ifndef  FUN_H
	#defien  FUN_H
	
	（1）函数声明
	（2）结构体定义
	（3）枚举型变量的定义
	（4）数组定义
	（5）...
	
	#endif

~进制转化
	
·					2进制				8进制				10进制					16进制
	表示			0-1，逢2进1			0-7，逢8进1			0-9，逢10进1			0-9 a-f，逢16进1
	表示方式        0b...				0...				...						0x...
	输出格式符		无					%o					%d						%x
	内存占用		

~文件大小单位换算
	1）Bit：比特，也称二进制位
	2）Byte：字节，一个汉字占2Bit，1Byte=8Bit
	3）KB：千字节，1KB=1024Byte
	4）MB：兆字节，1MB=1024KB
	5）GB：吉字节，1GB-1024MB
	6）TB：千吉字节，1TB=1024GB

~按位处理后赋值
	1）>>=	按位右移后赋值
		代码zhi示例为：x = 8; 
		x >>= 3; 
		右移后结果为：00000000 00000000 00000000 00000001
	2）<<=	按位左移后赋值
		代码示例为：
		x = 8;
		x <<= 3; 
		左移后赋值结果为：00000000 00000000 00000000 01000000
	3）&= 	按位与后赋值
		代码示例为：
		x = 0x02; 
		x &= 0x01; 
		按位与后的结果为：0x00
	4）^= 	按位异或后赋值
		代码示例为：
		x = 0x02; 
		x ^= 0x01; 
		按位异或的结果为：0x03 等同于0011
	5）|= 	按位或后赋值
		代码示例为：
		x = 0x02; 
		x  |= 0x01;
		按位或的结果为：0x03 等同于0011